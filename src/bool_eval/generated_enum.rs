//! Generated Boolean operations enum.
//!
//! This file is AUTO-GENERATED by `generate_boolean_ops.py`
//! Do not edit manually!
#![allow(missing_docs)]

use strum::{Display, EnumCount, EnumString, FromRepr, VariantArray, VariantNames};

/// All 278 Boolean operations on 0-3 variables.
///
/// Total operations: 278 = `2^(2^0)` + `2^(2^1)` + `2^(2^2)` + `2^(2^3)`
///
/// Discriminant encoding: `0xN_CC` where:
/// - `N` = arity (0, 1, 2, or 3)
/// - `CC` = truth table with inputs a=0xaa, b=0xcc, c=0xf0
///
/// Count by arity:
/// - Nullary: 2 operations (`2^(2^0)` = 2)
/// - Unary: 4 operations (`2^(2^1)` = 4)
/// - Binary: 16 operations (`2^(2^2)` = 16)
/// - Ternary: 256 operations (`2^(2^3)` = 256)
#[derive(
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    Display,
    EnumCount,
    EnumString,
    FromRepr,
    VariantArray,
    VariantNames,
)]
#[repr(u16)]
pub enum BooleanSimpleOp {
    /// Constant false.
    ///
    /// Expression: `false`
    #[strum(props(Expr = "false"))]
    False0 = 0x0_00,
    /// Constant true.
    ///
    /// Expression: `true`
    #[strum(props(Expr = "true"))]
    True0 = 0x0_ff,
    /// Constant false. See `False0`.
    ///
    /// Expression: `false`
    ///
    /// Note: Promoted from `False0` (arity 0).
    #[strum(props(Expr = "false"))]
    False1 = 0x1_00,
    /// Logical negation on first (only) variable.
    ///
    /// Expression: `!a`
    #[strum(props(Expr = "!a"))]
    NotA1 = 0x1_55,
    /// Identity function on first (only) variable.
    ///
    /// Expression: `a`
    #[strum(props(Expr = "a"))]
    IdA1 = 0x1_aa,
    /// Constant true. See `True0`.
    ///
    /// Expression: `true`
    ///
    /// Note: Promoted from `True0` (arity 0).
    #[strum(props(Expr = "true"))]
    True1 = 0x1_ff,
    /// Constant false. See `False0`.
    ///
    /// Expression: `false`
    ///
    /// Note: Promoted from `False0` (arity 0).
    #[strum(props(Expr = "false"))]
    False2 = 0x2_00,
    /// NOR operator on first two variables.
    ///
    /// Expression: `!(a | b)`
    #[strum(props(Expr = "!(a | b)"))]
    NotOrAB2 = 0x2_11,
    /// Not(a implies b). Inhibition, And(a, not b).
    ///
    /// Expression: `(a & !b)`
    ///
    /// Aliases: `AndANotB2`
    #[strum(props(Expr = "(a & !b)"))]
    NotImpliesAB2 = 0x2_22,
    /// Logical negation on second variable. See `NotA1`.
    ///
    /// Expression: `!b`
    #[strum(props(Expr = "!b"))]
    NotB2 = 0x2_33,
    /// Not(b implies a). Inhibition, And(not a, b).
    ///
    /// Expression: `(b & !a)`
    ///
    /// Aliases: `AndNotAB2`
    #[strum(props(Expr = "(b & !a)"))]
    NotImpliesBA2 = 0x2_44,
    /// Logical negation on first variable.
    ///
    /// Expression: `!a`
    ///
    /// Note: Promoted from `NotA1` (arity 1).
    #[strum(props(Expr = "!a"))]
    NotA2 = 0x2_55,
    /// Logical XOR (Exclusive Or) operator on first two variables.
    ///
    /// Expression: `(a ^ b)`
    ///
    /// Aliases: `ExclusiveOrAB2`
    #[strum(props(Expr = "(a ^ b)"))]
    XorAB2 = 0x2_66,
    /// Logical NAND operator on first two variables.
    ///
    /// Expression: `!(a & b)`
    ///
    /// Aliases: `NandAB2`
    #[strum(props(Expr = "!(a & b)"))]
    NotAndAB2 = 0x2_77,
    /// Logical AND operator on first two variables.
    ///
    /// Expression: `(a & b)`
    #[strum(props(Expr = "(a & b)"))]
    AndAB2 = 0x2_88,
    /// Logical equivalence (XNOR) operator on first two variables.
    ///
    /// Expression: `!(a ^ b)`
    ///
    /// Aliases: `BiimpAB2`, `EqAB2`, `NotXorAB2`
    #[strum(props(Expr = "!(a ^ b)"))]
    BiimpAB2 = 0x2_99,
    /// Identity on first variable.
    ///
    /// Expression: `a`
    ///
    /// Note: Promoted from `IdA1` (arity 1).
    #[strum(props(Expr = "a"))]
    IdA2 = 0x2_aa,
    /// Reverse implication (B implies A).
    ///
    /// Expression: `(!b | a)`
    ///
    /// Aliases: `OrANotB2`
    #[strum(props(Expr = "(!b | a)"))]
    ImpliesBA2 = 0x2_bb,
    /// Identity on second variable.
    ///
    /// Expression: `b`
    #[strum(props(Expr = "b"))]
    IdB2 = 0x2_cc,
    /// Material implication (A implies B).
    ///
    /// Expression: `(!a | b)`
    ///
    /// Aliases: `OrNotAB2`
    #[strum(props(Expr = "(!a | b)"))]
    ImpliesAB2 = 0x2_dd,
    /// Logical OR (Exclusive Or) operator on first two variables.
    ///
    /// Expression: `(a | b)`
    #[strum(props(Expr = "(a | b)"))]
    OrAB2 = 0x2_ee,
    /// Constant true. See `True0`.
    ///
    /// Expression: `true`
    ///
    /// Note: Promoted from `True0` (arity 0).
    #[strum(props(Expr = "true"))]
    True2 = 0x2_ff,
    /// Constant false. See `False0`.
    ///
    /// Expression: `false`
    ///
    /// Note: Promoted from `False0` (arity 0).
    #[strum(props(Expr = "false"))]
    False3 = 0x3_00,
    /// Three-way NOR operator.
    ///
    /// Expression: `!(a | b | c)`
    #[strum(props(Expr = "!(a | b | c)"))]
    NotOr3ABC3 = 0x3_01,
    /// True only when all of a, not b, and not c are.
    ///
    /// Expression: `!(!a | b | c)`
    #[strum(props(Expr = "!(!a | b | c)"))]
    NotOr3NotABC3 = 0x3_02,
    /// Nor(b, c).
    ///
    /// Expression: `!(b | c)`
    #[strum(props(Expr = "!(b | c)"))]
    NotOrBC3 = 0x3_03,
    /// True only when all of not a, b, and not c are.
    ///
    /// Expression: `!(a | !b | c)`
    #[strum(props(Expr = "!(a | !b | c)"))]
    NotOr3ANotBC3 = 0x3_04,
    /// Nor(a, c).
    ///
    /// Expression: `!(a | c)`
    #[strum(props(Expr = "!(a | c)"))]
    NotOrAC3 = 0x3_05,
    /// And(not c, Xor(a, b))
    ///
    /// Expression: `(!c & (a ^ b))`
    #[strum(props(Expr = "(!c & (a ^ b))"))]
    AndNotCXorAB3 = 0x3_06,
    /// NotOr(c, And(a, b))
    ///
    /// Expression: `!(c | (a & b))`
    #[strum(props(Expr = "!(c | (a & b))"))]
    NotOrCAndAB3 = 0x3_07,
    /// True only when all of a, b, and not c are.
    ///
    /// Expression: `(a & b & !c)`
    #[strum(props(Expr = "(a & b & !c)"))]
    And3ABNotC3 = 0x3_08,
    /// not Or(a, Xor(b, c))
    ///
    /// Expression: `!(c | (a ^ b))`
    #[strum(props(Expr = "!(c | (a ^ b))"))]
    NotOrCXorAB3 = 0x3_09,
    /// Not(Implies(a, c)).
    ///
    /// Expression: `(a & !c)`
    #[strum(props(Expr = "(a & !c)"))]
    NotImpliesAC3 = 0x3_0a,
    /// And(not c, Or(a, not b))
    ///
    /// Expression: `(!c & (a | !b))`
    #[strum(props(Expr = "(!c & (a | !b))"))]
    AndNotCOrANotB3 = 0x3_0b,
    /// Not(Implies(b, c)).
    ///
    /// Expression: `(b & !c)`
    #[strum(props(Expr = "(b & !c)"))]
    NotImpliesBC3 = 0x3_0c,
    /// And(not c, Or(not a, b))
    ///
    /// Expression: `(!c & (!a | b))`
    #[strum(props(Expr = "(!c & (!a | b))"))]
    AndNotCOrNotAB3 = 0x3_0d,
    /// And(not c, Or(a, b))
    ///
    /// Expression: `(!c & (a | b))`
    #[strum(props(Expr = "(!c & (a | b))"))]
    AndNotCOrAB3 = 0x3_0e,
    /// Negation of c.
    ///
    /// Expression: `!c`
    #[strum(props(Expr = "!c"))]
    NotC3 = 0x3_0f,
    /// True only when all of not a, not b, and c are.
    ///
    /// Expression: `!(a | b | !c)`
    #[strum(props(Expr = "!(a | b | !c)"))]
    NotOr3ABNotC3 = 0x3_10,
    /// NOR operator on first two variables.
    ///
    /// Expression: `!(a | b)`
    ///
    /// Note: Promoted from `NotOrAB2` (arity 2).
    #[strum(props(Expr = "!(a | b)"))]
    NotOrAB3 = 0x3_11,
    /// And(not b, Xor(a, c))
    ///
    /// Expression: `(!b & (a ^ c))`
    #[strum(props(Expr = "(!b & (a ^ c))"))]
    AndNotBXorAC3 = 0x3_12,
    /// NotOr(b, And(a, c))
    ///
    /// Expression: `!(b | (a & c))`
    #[strum(props(Expr = "!(b | (a & c))"))]
    NotOrBAndAC3 = 0x3_13,
    /// And(not a, Xor(b, c))
    ///
    /// Expression: `(!a & (b ^ c))`
    #[strum(props(Expr = "(!a & (b ^ c))"))]
    AndNotAXorBC3 = 0x3_14,
    /// NotOr(a, And(b, c))
    ///
    /// Expression: `!(a | (b & c))`
    #[strum(props(Expr = "!(a | (b & c))"))]
    NotOrAAndBC3 = 0x3_15,
    /// Exactly one of the three inputs is true
    ///
    /// Expression: `!((a & b) | (!a ^ b ^ c))`
    #[strum(props(Expr = "!((a & b) | (!a ^ b ^ c))"))]
    NotOrAndABNotXor3ABC3 = 0x316,
    /// Minority function (at least 2 of 3 false).
    ///
    /// Expression: `!(a & b | a & c | b & c)`
    ///
    /// Aliases: `NotCarryABC3`
    #[strum(props(Expr = "!(a & b | a & c | b & c)"))]
    NotMajority3ABC3 = 0x3_17,
    /// Variable a equals b but differs from c (so b differs from c)
    ///
    /// Expression: `(!(a ^ b) & (a ^ c))`
    #[strum(props(Expr = "(!(a ^ b) & (a ^ c))"))]
    AndBiimpABXorAC3 = 0x3_18,
    /// Variable a equals b, and not both a and c
    ///
    /// Expression: `!((a ^ b) | (a & c))`
    #[strum(props(Expr = "!((a ^ b) | (a & c))"))]
    NotOrXorABAndAC3 = 0x3_19,
    /// Variable a differs from c, and not both b and c
    ///
    /// Expression: `!(!(a ^ c) | (b & c))`
    #[strum(props(Expr = "!(!(a ^ c) | (b & c))"))]
    NotOrBiimpACAndBC3 = 0x3_1a,
    /// If a then not c else not b (negated multiplexer).
    ///
    /// Expression: `!(a & c | !a & b)`
    ///
    /// Aliases: `NotMuxACB3`
    #[strum(props(Expr = "!(a & c | !a & b)"))]
    NotIfACB3 = 0x3_1b,
    /// Variable b differs from c, and not both a and c
    ///
    /// Expression: `!(!(b ^ c) | (a & c))`
    #[strum(props(Expr = "!(!(b ^ c) | (a & c))"))]
    NotOrBiimpBCAndAC3 = 0x3_1c,
    /// If b then not c else not a (negated multiplexer).
    ///
    /// Expression: `!(b & c | !b & a)`
    ///
    /// Aliases: `NotMuxBCA3`
    #[strum(props(Expr = "!(b & c | !b & a)"))]
    NotIfBCA3 = 0x3_1d,
    /// Variable c differs from the disjunction of a and b
    ///
    /// Expression: `(c ^ (a | b))`
    #[strum(props(Expr = "(c ^ (a | b))"))]
    XorCOrAB3 = 0x3_1e,
    /// Or(a, b) implies not c.
    ///
    /// Expression: `(!(a | b) | !c)`
    #[strum(props(Expr = "(!(a | b) | !c)"))]
    ImpliesOrABNotC3 = 0x3_1f,
    /// True only when all of a, not b, and c are.
    ///
    /// Expression: `(a & !b & c)`
    #[strum(props(Expr = "(a & !b & c)"))]
    And3ANotBC3 = 0x3_20,
    /// not Or(a, Xor(b, c))
    ///
    /// Expression: `!(b | (a ^ c))`
    #[strum(props(Expr = "!(b | (a ^ c))"))]
    NotOrBXorAC3 = 0x3_21,
    /// Not(a implies b). Inhibition, And(a, not b).
    ///
    /// Expression: `(a & !b)`
    ///
    /// Note: Promoted from `NotImpliesAB2` (arity 2).
    ///
    /// Aliases: `AndANotB3`
    #[strum(props(Expr = "(a & !b)"))]
    NotImpliesAB3 = 0x3_22,
    /// And(not b, Or(a, not c))
    ///
    /// Expression: `(!b & (a | !c))`
    #[strum(props(Expr = "(!b & (a | !c))"))]
    AndNotBOrANotC3 = 0x3_23,
    /// Variable a differs from b but equals c (so b differs from c)
    ///
    /// Expression: `((a ^ b) & !(a ^ c))`
    #[strum(props(Expr = "((a ^ b) & !(a ^ c))"))]
    AndXorABBiimpAC3 = 0x3_24,
    /// Variable a equals c, and not both a and b
    ///
    /// Expression: `!((a ^ c) | (a & b))`
    #[strum(props(Expr = "!((a ^ c) | (a & b))"))]
    NotOrXorACAndAB3 = 0x3_25,
    /// Variable a differs from b, and not both b and c
    ///
    /// Expression: `!(!(a ^ b) | (b & c))`
    #[strum(props(Expr = "!(!(a ^ b) | (b & c))"))]
    NotOrBiimpABAndBC3 = 0x3_26,
    /// If a then not b else not c (negated multiplexer).
    ///
    /// Expression: `!(a & b | !a & c)`
    ///
    /// Aliases: `NotMuxABC3`
    #[strum(props(Expr = "!(a & b | !a & c)"))]
    NotIfABC3 = 0x3_27,
    /// And(a, Xor(b, c))
    ///
    /// Expression: `(a & (b ^ c))`
    #[strum(props(Expr = "(a & (b ^ c))"))]
    AndAXorBC3 = 0x3_28,
    /// Even parity (0 or 2 inputs), but not when both b and c are true
    ///
    /// Expression: `!((b & c) | (a ^ b ^ c))`
    #[strum(props(Expr = "!((b & c) | (a ^ b ^ c))"))]
    NotOrAndBCXor3ABC3 = 0x3_29,
    /// NotOr(not a, And(b, c))
    ///
    /// Expression: `!(!a | (b & c))`
    #[strum(props(Expr = "!(!a | (b & c))"))]
    NotOrNotAAndBC3 = 0x3_2a,
    /// Minority function (true when least 2 of not a, b, c are false)
    ///
    /// Expression: `!(!a & b | !a & c | b & c)`
    #[strum(props(Expr = "!(!a & b | !a & c | b & c)"))]
    NotMajority3NotABC3 = 0x3_2b,
    /// Exactly one of b or c is true, while at least one of a or b
    ///
    /// Expression: `((b ^ c) & (a | b))`
    #[strum(props(Expr = "((b ^ c) & (a | b))"))]
    AndXorBCOrAB3 = 0x3_2c,
    /// Variable c differs from (a implies b)
    ///
    /// Expression: `(c ^ (!a | b))`
    #[strum(props(Expr = "(c ^ (!a | b))"))]
    XorCOrNotAB3 = 0x3_2d,
    /// If b then not c else a (multiplexer, negated input).
    ///
    /// Expression: `(b & !c | !b & a)`
    ///
    /// Aliases: `MuxBNotCA3`
    #[strum(props(Expr = "(b & !c | !b & a)"))]
    IfBNotCA3 = 0x3_2e,
    /// Implies(Implies(a, b), not c)
    ///
    /// Expression: `(!(!a | b) | !c)`
    #[strum(props(Expr = "(!(!a | b) | !c)"))]
    ImpliesImpliesABNotC3 = 0x3_2f,
    /// Not(Implies(c, b)).
    ///
    /// Expression: `(c & !b)`
    #[strum(props(Expr = "(c & !b)"))]
    NotImpliesCB3 = 0x3_30,
    /// And(not b, Or(not a, c))
    ///
    /// Expression: `(!b & (!a | c))`
    #[strum(props(Expr = "(!b & (!a | c))"))]
    AndNotBOrNotAC3 = 0x3_31,
    /// And(not b, Or(a, c))
    ///
    /// Expression: `(!b & (a | c))`
    #[strum(props(Expr = "(!b & (a | c))"))]
    AndNotBOrAC3 = 0x332,
    /// Logical negation on second variable. See `NotA1`.
    ///
    /// Expression: `!b`
    ///
    /// Note: Promoted from `NotB2` (arity 2).
    #[strum(props(Expr = "!b"))]
    NotB3 = 0x3_33,
    /// Variable b differs from c, and not both a and b
    ///
    /// Expression: `!(!(b ^ c) | (a & b))`
    #[strum(props(Expr = "!(!(b ^ c) | (a & b))"))]
    NotOrBiimpBCAndAB3 = 0x3_34,
    /// If c then not b else not a (negated multiplexer).
    ///
    /// Expression: `!(c & b | !c & a)`
    ///
    /// Aliases: `NotMuxCBA3`
    #[strum(props(Expr = "!(c & b | !c & a)"))]
    NotIfCBA3 = 0x3_35,
    /// Variable b differs from the disjunction of a and c
    ///
    /// Expression: `(b ^ (a | c))`
    #[strum(props(Expr = "(b ^ (a | c))"))]
    XorBOrAC3 = 0x3_36,
    /// Or(a, c) implies not b.
    ///
    /// Expression: `(!(a | c) | !b)`
    #[strum(props(Expr = "(!(a | c) | !b)"))]
    ImpliesOrACNotB3 = 0x3_37,
    /// Exactly one of b or c is true, while at least one of a or c
    ///
    /// Expression: `((b ^ c) & (a | c))`
    #[strum(props(Expr = "((b ^ c) & (a | c))"))]
    AndXorBCOrAC3 = 0x3_38,
    /// Variable b differs from (a implies c)
    ///
    /// Expression: `(b ^ (!a | c))`
    #[strum(props(Expr = "(b ^ (!a | c))"))]
    XorBOrNotAC3 = 0x3_39,
    /// If c then not b else a (multiplexer, negated input).
    ///
    /// Expression: `(c & !b | !c & a)`
    ///
    /// Aliases: `MuxCNotBA3`
    #[strum(props(Expr = "(c & !b | !c & a)"))]
    IfCNotBA3 = 0x3_3a,
    /// Implies(Implies(a, c), not b)
    ///
    /// Expression: `(!(!a | c) | !b)`
    #[strum(props(Expr = "(!(!a | c) | !b)"))]
    ImpliesImpliesACNotB3 = 0x3_3b,
    /// Xor(b, c).
    ///
    /// Expression: `(b ^ c)`
    #[strum(props(Expr = "(b ^ c)"))]
    XorBC3 = 0x3_3c,
    /// Either b differs from c, or neither a nor b is true
    ///
    /// Expression: `!(!(b ^ c) & (a | b))`
    #[strum(props(Expr = "!(!(b ^ c) & (a | b))"))]
    NotAndBiimpBCOrAB3 = 0x3_3d,
    /// Either c differs from b, or both not-c and a are true
    ///
    /// Expression: `((c ^ b) | (!c & a))`
    #[strum(props(Expr = "((c ^ b) | (!c & a))"))]
    OrXorCBAndNotCA3 = 0x3_3e,
    /// Nand(b, c).
    ///
    /// Expression: `!(b & c)`
    #[strum(props(Expr = "!(b & c)"))]
    NotAndBC3 = 0x3_3f,
    /// True only when all of not a, b, and c are.
    ///
    /// Expression: `(!a & b & c)`
    #[strum(props(Expr = "(!a & b & c)"))]
    And3NotABC3 = 0x3_40,
    /// not Or(a, Xor(b, c))
    ///
    /// Expression: `!(a | (b ^ c))`
    #[strum(props(Expr = "!(a | (b ^ c))"))]
    NotOrAXorBC3 = 0x3_41,
    /// Variable a differs from both b and c (so b equals c)
    ///
    /// Expression: `((a ^ b) & (a ^ c))`
    #[strum(props(Expr = "((a ^ b) & (a ^ c))"))]
    AndXorABXorAC3 = 0x3_42,
    /// Variable b equals c, and not both a and b
    ///
    /// Expression: `!((b ^ c) | (a & b))`
    #[strum(props(Expr = "!((b ^ c) | (a & b))"))]
    NotOrXorBCAndAB3 = 0x3_43,
    /// Not(b implies a). Inhibition, And(not a, b).
    ///
    /// Expression: `(b & !a)`
    ///
    /// Note: Promoted from `NotImpliesBA2` (arity 2).
    ///
    /// Aliases: `AndNotAB2`
    #[strum(props(Expr = "(b & !a)"))]
    NotImpliesBA3 = 0x3_44,
    /// And(not a, Or(b, not c))
    ///
    /// Expression: `(!a & (b | !c))`
    #[strum(props(Expr = "(!a & (b | !c))"))]
    AndNotAOrBNotC3 = 0x3_45,
    /// Variable a differs from b, and not both a and c
    ///
    /// Expression: `!(!(a ^ b) | (a & c))`
    #[strum(props(Expr = "!(!(a ^ b) | (a & c))"))]
    NotOrBiimpABAndAC3 = 0x3_46,
    /// If b then not a else not c (negated multiplexer).
    ///
    /// Expression: `!(b & a | !b & c)`
    ///
    /// Aliases: `NotMuxBAC3`
    #[strum(props(Expr = "!(b & a | !b & c)"))]
    NotIfBAC3 = 0x3_47,
    /// And(b, Xor(a, c))
    ///
    /// Expression: `(b & (a ^ c))`
    #[strum(props(Expr = "(b & (a ^ c))"))]
    AndBXorAC3 = 0x3_48,
    /// Even parity (0 or 2 inputs), but not when both a and c are true
    ///
    /// Expression: `!((a & c) | (a ^ b ^ c))`
    #[strum(props(Expr = "!((a & c) | (a ^ b ^ c))"))]
    NotOrAndACXor3ABC3 = 0x3_49,
    /// Exactly one of a or c is true, while at least one of a or b
    ///
    /// Expression: `((a ^ c) & (a | b))`
    #[strum(props(Expr = "((a ^ c) & (a | b))"))]
    AndXorACOrAB3 = 0x3_4a,
    /// Variable c equals (not-a and b)
    ///
    /// Expression: `!(c ^ (!a & b))`
    #[strum(props(Expr = "!(c ^ (!a & b))"))]
    BiimpCAndNotAB3 = 0x3_4b,
    /// NotOr(not b, And(a, c))
    ///
    /// Expression: `!(!b | (a & c))`
    #[strum(props(Expr = "!(!b | (a & c))"))]
    NotOrNotBAndAC3 = 0x3_4c,
    /// Minority function (true when least 2 of a, not b, c are false)
    ///
    /// Expression: `!(a & !b | a & c | !b & c)`
    #[strum(props(Expr = "!(a & !b | a & c | !b & c)"))]
    NotMajority3ANotBC3 = 0x3_4d,
    /// If a then not c else b (multiplexer, negated input).
    ///
    /// Expression: `(a & !c | !a & b)`
    ///
    /// Aliases: `MuxANotCB3`
    #[strum(props(Expr = "(a & !c | !a & b)"))]
    IfANotCB3 = 0x3_4e,
    /// Implies(Implies(b, a), not c)
    ///
    /// Expression: `(!(!b | a) | !c)`
    #[strum(props(Expr = "(!(!b | a) | !c)"))]
    ImpliesImpliesBANotC3 = 0x3_4f,
    /// Not(Implies(c, a)).
    ///
    /// Expression: `(c & !a)`
    #[strum(props(Expr = "(c & !a)"))]
    NotImpliesCA3 = 0x3_50,
    /// And(not a, Or(not b, c))
    ///
    /// Expression: `(!a & (!b | c))`
    #[strum(props(Expr = "(!a & (!b | c))"))]
    AndNotAOrNotBC3 = 0x3_51,
    /// Variable a differs from c, and not both a and b
    ///
    /// Expression: `!(!(a ^ c) | (a & b))`
    #[strum(props(Expr = "!(!(a ^ c) | (a & b))"))]
    NotOrBiimpACAndAB3 = 0x3_52,
    /// If c then not a else not b (negated multiplexer).
    ///
    /// Expression: `!(c & a | !c & b)`
    ///
    /// Aliases: `NotMuxCAB3`
    #[strum(props(Expr = "!(c & a | !c & b)"))]
    NotIfCAB3 = 0x3_53,
    /// And(not a, Or(b, c))
    ///
    /// Expression: `(!a & (b | c))`
    #[strum(props(Expr = "(!a & (b | c))"))]
    AndNotAOrBC3 = 0x3_54,
    /// Logical negation on first variable.
    ///
    /// Expression: `!a`
    ///
    /// Note: Promoted from `NotA1` (arity 1).
    #[strum(props(Expr = "!a"))]
    NotA3 = 0x3_55,
    /// Variable a differs from the disjunction of b and c
    ///
    /// Expression: `(a ^ (b | c))`
    #[strum(props(Expr = "(a ^ (b | c))"))]
    XorAOrBC3 = 0x3_56,
    /// Or(b, c) implies not a.
    ///
    /// Expression: `(!(b | c) | !a)`
    #[strum(props(Expr = "(!(b | c) | !a)"))]
    ImpliesOrBCNotA3 = 0x3_57,
    /// Exactly one of a or c is true, while at least one of b or c
    ///
    /// Expression: `((a ^ c) & (b | c))`
    #[strum(props(Expr = "((a ^ c) & (b | c))"))]
    AndXorACOrBC3 = 0x3_58,
    /// Variable a differs from (b implies c)
    ///
    /// Expression: `(a ^ (!b | c))`
    #[strum(props(Expr = "(a ^ (!b | c))"))]
    XorAOrNotBC3 = 0x3_59,
    /// Xor(a, c).
    ///
    /// Expression: `(a ^ c)`
    #[strum(props(Expr = "(a ^ c)"))]
    XorAC3 = 0x3_5a,
    /// Either a differs from c, or neither a nor b is true
    ///
    /// Expression: `!(!(a ^ c) & (a | b))`
    #[strum(props(Expr = "!(!(a ^ c) & (a | b))"))]
    NotAndBiimpACOrAB3 = 0x3_5b,
    /// If c then not a else b (multiplexer, negated input).
    ///
    /// Expression: `(c & !a | !c & b)`
    ///
    /// Aliases: `MuxCNotAB3`
    #[strum(props(Expr = "(c & !a | !c & b)"))]
    IfCNotAB3 = 0x3_5c,
    /// Implies(Implies(b, c), not a)
    ///
    /// Expression: `(!(!b | c) | !a)`
    #[strum(props(Expr = "(!(!b | c) | !a)"))]
    ImpliesImpliesBCNotA3 = 0x3_5d,
    /// Either a differs from c, or both not-a and b are true
    ///
    /// Expression: `((a ^ c) | (!a & b))`
    #[strum(props(Expr = "((a ^ c) | (!a & b))"))]
    OrXorACAndNotAB3 = 0x3_5e,
    /// Nand(a, c).
    ///
    /// Expression: `!(a & c)`
    #[strum(props(Expr = "!(a & c)"))]
    NotAndAC3 = 0x3_5f,
    /// And(c, Xor(a, b))
    ///
    /// Expression: `(c & (a ^ b))`
    #[strum(props(Expr = "(c & (a ^ b))"))]
    AndCXorAB3 = 0x3_60,
    /// Even parity (0 or 2 inputs), but not when both a and b are true
    ///
    /// Expression: `!((a & b) | (a ^ b ^ c))`
    #[strum(props(Expr = "!((a & b) | (a ^ b ^ c))"))]
    NotOrAndABXor3ABC3 = 0x3_61,
    /// Exactly one of a or b is true, while at least one of a or c
    ///
    /// Expression: `((a ^ b) & (a | c))`
    #[strum(props(Expr = "((a ^ b) & (a | c))"))]
    AndXorABOrAC3 = 0x3_62,
    /// Variable b equals (not-a and c)
    ///
    /// Expression: `!(b ^ (!a & c))`
    #[strum(props(Expr = "!(b ^ (!a & c))"))]
    BiimpBAndNotAC3 = 0x3_63,
    /// Exactly one of a or b is true, while at least one of b or c
    ///
    /// Expression: `((a ^ b) & (b | c))`
    #[strum(props(Expr = "((a ^ b) & (b | c))"))]
    AndXorABOrBC3 = 0x364,
    /// Variable a equals (not-b and c)
    ///
    /// Expression: `!(a ^ (!b & c))`
    #[strum(props(Expr = "!(a ^ (!b & c))"))]
    BiimpAAndNotBC3 = 0x3_65,
    /// Logical XOR (Exclusive Or) operator on first two variables.
    ///
    /// Expression: `(a ^ b)`
    ///
    /// Note: Promoted from `XorAB2` (arity 2).
    ///
    /// Aliases: `ExclusiveOrAB2`
    #[strum(props(Expr = "(a ^ b)"))]
    XorAB3 = 0x3_66,
    /// Either a differs from b, or neither a nor c is true
    ///
    /// Expression: `!(!(a ^ b) & (a | c))`
    #[strum(props(Expr = "!(!(a ^ b) & (a | c))"))]
    NotAndBiimpABOrAC3 = 0x3_67,
    /// At least one of a or b, and even parity of all three
    ///
    /// Expression: `!(!(a | b) | (a ^ b ^ c))`
    #[strum(props(Expr = "!(!(a | b) | (a ^ b ^ c))"))]
    NotOrNotOrABXor3ABC3 = 0x3_68,
    /// Three-way XNOR operator (even parity).
    ///
    /// Expression: `(!a ^ b ^ c)`
    #[strum(props(Expr = "(!a ^ b ^ c)"))]
    NotXor3ABC3 = 0x3_69,
    /// Variable a differs from the conjunction of b and c
    ///
    /// Expression: `(a ^ (b & c))`
    #[strum(props(Expr = "(a ^ (b & c))"))]
    XorAAndBC3 = 0x3_6a,
    /// Either even parity of all three, or both a and not-b are true
    ///
    /// Expression: `((!a ^ b ^ c) | (a & !b))`
    #[strum(props(Expr = "((!a ^ b ^ c) | (a & !b))"))]
    OrNotXor3ABCAndANotB3 = 0x3_6b,
    /// Variable b differs from the conjunction of a and c
    ///
    /// Expression: `(b ^ (a & c))`
    #[strum(props(Expr = "(b ^ (a & c))"))]
    XorBAndAC3 = 0x3_6c,
    /// Either even parity of all three, or both not-a and b are true
    ///
    /// Expression: `((!a ^ b ^ c) | (!a & b))`
    #[strum(props(Expr = "((!a ^ b ^ c) | (!a & b))"))]
    OrNotXor3ABCAndNotAB3 = 0x3_6d,
    /// Either a differs from b, or both a and not-c are true
    ///
    /// Expression: `((a ^ b) | (a & !c))`
    #[strum(props(Expr = "((a ^ b) | (a & !c))"))]
    OrXorABAndANotC3 = 0x3_6e,
    /// c implies Xor(a, b).
    ///
    /// Expression: `(!c | (a ^ b))`
    #[strum(props(Expr = "(!c | (a ^ b))"))]
    ImpliesCXorAB3 = 0x3_6f,
    /// NotOr(not c, And(a, b))
    ///
    /// Expression: `!(!c | (a & b))`
    #[strum(props(Expr = "!(!c | (a & b))"))]
    NotOrNotCAndAB3 = 0x3_70,
    /// Minority function (true when least 2 of a, b, not c are false)
    ///
    /// Expression: `!(a & b | a & !c | b & !c)`
    #[strum(props(Expr = "!(a & b | a & !c | b & !c)"))]
    NotMajority3ABNotC3 = 0x3_71,
    /// If a then not b else c (multiplexer, negated input).
    ///
    /// Expression: `(a & !b | !a & c)`
    ///
    /// Aliases: `MuxANotBC3`
    #[strum(props(Expr = "(a & !b | !a & c)"))]
    IfANotBC3 = 0x3_72,
    /// Implies(Implies(c, a), not b)
    ///
    /// Expression: `(!(!c | a) | !b)`
    #[strum(props(Expr = "(!(!c | a) | !b)"))]
    ImpliesImpliesCANotB3 = 0x3_73,
    /// If b then not a else c (multiplexer, negated input).
    ///
    /// Expression: `(b & !a | !b & c)`
    ///
    /// Aliases: `MuxBNotAC3`
    #[strum(props(Expr = "(b & !a | !b & c)"))]
    IfBNotAC3 = 0x3_74,
    /// Implies(Implies(c, b), not a)
    ///
    /// Expression: `(!(!c | b) | !a)`
    #[strum(props(Expr = "(!(!c | b) | !a)"))]
    ImpliesImpliesCBNotA3 = 0x3_75,
    /// Either a differs from b, or both not-a and c are true
    ///
    /// Expression: `((a ^ b) | (!a & c))`
    #[strum(props(Expr = "((a ^ b) | (!a & c))"))]
    OrXorABAndNotAC3 = 0x3_76,
    /// Logical NAND operator on first two variables.
    ///
    /// Expression: `!(a & b)`
    ///
    /// Note: Promoted from `NotAndAB2` (arity 2).
    ///
    /// Aliases: `NandAB2`
    #[strum(props(Expr = "!(a & b)"))]
    NotAndAB3 = 0x3_77,
    /// Variable c differs from the conjunction of a and b
    ///
    /// Expression: `(c ^ (a & b))`
    #[strum(props(Expr = "(c ^ (a & b))"))]
    XorCAndAB3 = 0x3_78,
    /// Either even parity of all three, or both not-a and c are true
    ///
    /// Expression: `((!a ^ b ^ c) | (!a & c))`
    #[strum(props(Expr = "((!a ^ b ^ c) | (!a & c))"))]
    OrNotXor3ABCAndNotAC3 = 0x3_79,
    /// Either a differs from c, or both a and not-b are true
    ///
    /// Expression: `((a ^ c) | (a & !b))`
    #[strum(props(Expr = "((a ^ c) | (a & !b))"))]
    OrXorACAndANotB3 = 0x3_7a,
    /// b implies Xor(a, c).
    ///
    /// Expression: `(!b | (a ^ c))`
    #[strum(props(Expr = "(!b | (a ^ c))"))]
    ImpliesBXorAC3 = 0x3_7b,
    /// Either c differs from b, or both c and not-a are true
    ///
    /// Expression: `((c ^ b) | (c & !a))`
    #[strum(props(Expr = "((c ^ b) | (c & !a))"))]
    OrXorCBAndCNotA3 = 0x3_7c,
    /// a implies Xor(b, c).
    ///
    /// Expression: `(!a | (b ^ c))`
    #[strum(props(Expr = "(!a | (b ^ c))"))]
    ImpliesAXorBC3 = 0x3_7d,
    /// Variable a differs from b or from c (not all three equal)
    ///
    /// Expression: `((a ^ b) | (a ^ c))`
    #[strum(props(Expr = "((a ^ b) | (a ^ c))"))]
    OrXorABXorAC3 = 0x3_7e,
    /// Three-way NAND operator.
    ///
    /// Expression: `!(a & b & c)`
    #[strum(props(Expr = "!(a & b & c)"))]
    NotAnd3ABC3 = 0x3_7f,
    /// Three-way AND operator.
    ///
    /// Expression: `(a & b & c)`
    #[strum(props(Expr = "(a & b & c)"))]
    And3ABC3 = 0x3_80,
    /// All three variables are equal (neither parity holds)
    ///
    /// Expression: `!((a ^ b) | (a ^ c))`
    #[strum(props(Expr = "!((a ^ b) | (a ^ c))"))]
    NotOrXorABXorAC3 = 0x3_81,
    /// True iff a is true and b == c.
    ///
    /// Expression: `(a & !(b ^ c))`
    #[strum(props(Expr = "(a & !(b ^ c))"))]
    AndABiimpBC3 = 0x3_82,
    /// True iff b == c and b == ( a and c ).
    ///
    /// Expression: `(!(b ^ c) & (a | !b))`
    #[strum(props(Expr = "(!(b ^ c) & (a | !b))"))]
    AndBiimpBCOrANotB3 = 0x3_83,
    /// True iff b is true and a == c.
    ///
    /// Expression: `(b & !(a ^ c))`
    #[strum(props(Expr = "(b & !(a ^ c))"))]
    AndBBiimpAC3 = 0x3_84,
    /// True iff a == c and a == ( b and c ).
    ///
    /// Expression: `(!(a ^ c) & (!a | b))`
    #[strum(props(Expr = "(!(a ^ c) & (!a | b))"))]
    AndBiimpACOrNotAB3 = 0x3_85,
    /// Odd parity (1 or 3 inputs), but not when it is just c that is true
    ///
    /// Expression: `!((!a & c) | (!a ^ b ^ c))`
    #[strum(props(Expr = "!((!a & c) | (!a ^ b ^ c))"))]
    NotOrAndNotACNotXor3ABC3 = 0x3_86,
    /// Variable c equals the conjunction of a and b
    ///
    /// Expression: `!(c ^ (a & b))`
    #[strum(props(Expr = "!(c ^ (a & b))"))]
    BiimpCAndAB3 = 0x3_87,
    /// Logical AND operator on first two variables.
    ///
    /// Expression: `(a & b)`
    ///
    /// Note: Promoted from `AndAB2` (arity 2).
    #[strum(props(Expr = "(a & b)"))]
    AndAB3 = 0x3_88,
    /// True iff a == b and a == ( b or c ).
    ///
    /// Expression: `(!(a ^ b) & (a | !c))`
    #[strum(props(Expr = "(!(a ^ b) & (a | !c))"))]
    AndBiimpABOrANotC3 = 0x3_89,
    /// And(a, Or(b, not c))
    ///
    /// Expression: `(a & (b | !c))`
    #[strum(props(Expr = "(a & (b | !c))"))]
    AndAOrBNotC3 = 0x3_8a,
    /// If b then a else not c (multiplexer, negated input).
    ///
    /// Expression: `(b & a | !b & !c)`
    ///
    /// Aliases: `MuxBANotC3`
    #[strum(props(Expr = "(b & a | !b & !c)"))]
    IfBANotC3 = 0x3_8b,
    /// And(b, Or(a, not c))
    ///
    /// Expression: `(b & (a | !c))`
    #[strum(props(Expr = "(b & (a | !c))"))]
    AndBOrANotC3 = 0x3_8c,
    /// If a then b else not c (multiplexer, negated input).
    ///
    /// Expression: `(a & b | !a & !c)`
    ///
    /// Aliases: `MuxABNotC3`
    #[strum(props(Expr = "(a & b | !a & !c)"))]
    IfABNotC3 = 0x3_8d,
    /// Majority function (true when least 2 of a, b, not c are true)
    ///
    /// Expression: `(a & b | a & !c | b & !c)`
    #[strum(props(Expr = "(a & b | a & !c | b & !c)"))]
    Majority3ABNotC3 = 0x3_8e,
    /// c implies And(a, b).
    ///
    /// Expression: `(!c | (a & b))`
    #[strum(props(Expr = "(!c | (a & b))"))]
    ImpliesCAndAB3 = 0x3_8f,
    /// True iff c is true and a == b.
    ///
    /// Expression: `(c & !(a ^ b))`
    #[strum(props(Expr = "(c & !(a ^ b))"))]
    AndCBiimpAB3 = 0x3_90,
    /// True iff a == b and a == ( b and c ).
    ///
    /// Expression: `(!(a ^ b) & (!a | c))`
    #[strum(props(Expr = "(!(a ^ b) & (!a | c))"))]
    AndBiimpABOrNotAC3 = 0x3_91,
    /// Odd parity (1 or 3 inputs), but not when it is just b that is true
    ///
    /// Expression: `!((!a & b) | (!a ^ b ^ c))`
    #[strum(props(Expr = "!((!a & b) | (!a ^ b ^ c))"))]
    NotOrAndNotABNotXor3ABC3 = 0x3_92,
    /// Variable b equals the conjunction of a and c
    ///
    /// Expression: `!(b ^ (a & c))`
    #[strum(props(Expr = "!(b ^ (a & c))"))]
    BiimpBAndAC3 = 0x3_93,
    /// Odd parity (1 or 3 inputs), but not when it is just a that is true
    ///
    /// Expression: `!((a & !b) | (!a ^ b ^ c))`
    #[strum(props(Expr = "!((a & !b) | (!a ^ b ^ c))"))]
    NotOrAndANotBNotXor3ABC3 = 0x3_94,
    /// Variable a equals the conjunction of b and c
    ///
    /// Expression: `!(a ^ (b & c))`
    #[strum(props(Expr = "!(a ^ (b & c))"))]
    BiimpAAndBC3 = 0x3_95,
    /// Three-way XOR operator (odd parity).
    ///
    /// Expression: `(a ^ b ^ c)`
    #[strum(props(Expr = "(a ^ b ^ c)"))]
    Xor3ABC3 = 0x3_96,
    /// True iff zero or an odd number of a, b, and c are true.
    ///
    /// Expression: `((a ^ b ^ c) | !(a | b))`
    #[strum(props(Expr = "((a ^ b ^ c) | !(a | b))"))]
    OrXor3ABCNotOrAB3 = 0x3_97,
    /// Variables a and b are equal, while at least one of a or c
    ///
    /// Expression: `(!(a ^ b) & (a | c))`
    #[strum(props(Expr = "(!(a ^ b) & (a | c))"))]
    AndBiimpABOrAC3 = 0x3_98,
    /// Logical equivalence (XNOR) operator on first two variables.
    ///
    /// Expression: `!(a ^ b)`
    ///
    /// Note: Promoted from `NotXorAB2` (arity 2).
    ///
    /// Aliases: `BiimpAB2`, `EqAB2`, `NotXorAB2`
    #[strum(props(Expr = "!(a ^ b)"))]
    BiimpAB3 = 0x3_99,
    /// Variable a differs from both not-b and c
    ///
    /// Expression: `(a ^ (!b & c))`
    #[strum(props(Expr = "(a ^ (!b & c))"))]
    XorAAndNotBC3 = 0x3_9a,
    /// Either a equals b, or neither b nor c is true
    ///
    /// Expression: `!((a ^ b) & (b | c))`
    #[strum(props(Expr = "!((a ^ b) & (b | c))"))]
    NotAndXorABOrBC3 = 0x3_9b,
    /// Variable b differs from both not-a and c
    ///
    /// Expression: `(b ^ (!a & c))`
    #[strum(props(Expr = "(b ^ (!a & c))"))]
    XorBAndNotAC3 = 0x3_9c,
    /// Either a equals b, or neither a nor c is true
    ///
    /// Expression: `!((a ^ b) & (a | c))`
    #[strum(props(Expr = "!((a ^ b) & (a | c))"))]
    NotAndXorABOrAC3 = 0x3_9d,
    /// Either odd parity of all three, or both a and b are true
    ///
    /// Expression: `((a ^ b ^ c) | (a & b))`
    #[strum(props(Expr = "((a ^ b ^ c) | (a & b))"))]
    OrXor3ABCAndAB3 = 0x3_9e,
    /// Xor(a, b) implies not c.
    ///
    /// Expression: `(!(a ^ b) | !c)`
    #[strum(props(Expr = "(!(a ^ b) | !c)"))]
    ImpliesXorABNotC3 = 0x3_9f,
    /// And(a, c).
    ///
    /// Expression: `(a & c)`
    #[strum(props(Expr = "(a & c)"))]
    AndAC3 = 0x3_a0,
    /// True iff a == c and a == ( b or c ).
    ///
    /// Expression: `(!(a ^ c) & (a | !b))`
    #[strum(props(Expr = "(!(a ^ c) & (a | !b))"))]
    AndBiimpACOrANotB3 = 0x3_a1,
    /// And(a, Or(not b, c))
    ///
    /// Expression: `(a & (!b | c))`
    #[strum(props(Expr = "(a & (!b | c))"))]
    AndAOrNotBC3 = 0x3_a2,
    /// If c then a else not b (multiplexer, negated input).
    ///
    /// Expression: `(c & a | !c & !b)`
    ///
    /// Aliases: `MuxCANotB3`
    #[strum(props(Expr = "(c & a | !c & !b)"))]
    IfCANotB3 = 0x3_a3,
    /// Variables a and c are equal, while at least one of a or b
    ///
    /// Expression: `(!(a ^ c) & (a | b))`
    #[strum(props(Expr = "(!(a ^ c) & (a | b))"))]
    AndBiimpACOrAB3 = 0x3_a4,
    /// Biimp(a, c).
    ///
    /// Expression: `!(a ^ c)`
    #[strum(props(Expr = "!(a ^ c)"))]
    BiimpAC3 = 0x3_a5,
    /// Variable a equals (b implies c)
    ///
    /// Expression: `!(a ^ (!b | c))`
    #[strum(props(Expr = "!(a ^ (!b | c))"))]
    BiimpAOrNotBC3 = 0x3_a6,
    /// Either a equals c, or neither b nor c is true
    ///
    /// Expression: `!((a ^ c) & (b | c))`
    #[strum(props(Expr = "!((a ^ c) & (b | c))"))]
    NotAndXorACOrBC3 = 0x3_a7,
    /// And(a, Or(b, c))
    ///
    /// Expression: `(a & (b | c))`
    #[strum(props(Expr = "(a & (b | c))"))]
    AndAOrBC3 = 0x3_a8,
    /// Variable a equals the disjunction of b and c
    ///
    /// Expression: `!(a ^ (b | c))`
    #[strum(props(Expr = "!(a ^ (b | c))"))]
    BiimpAOrBC3 = 0x3_a9,
    /// Identity on first variable.
    ///
    /// Expression: `a`
    ///
    /// Note: Promoted from `IdA1` (arity 1).
    #[strum(props(Expr = "a"))]
    IdA3 = 0x3_aa,
    /// Or(b, c) implies a.
    ///
    /// Expression: `(!(b | c) | a)`
    #[strum(props(Expr = "(!(b | c) | a)"))]
    ImpliesOrBCA3 = 0x3_ab,
    /// If c then a else b (multiplexer).
    ///
    /// Expression: `(c & a | !c & b)`
    ///
    /// Aliases: `MuxCAB3`
    #[strum(props(Expr = "(c & a | !c & b)"))]
    IfCAB3 = 0x3_ac,
    /// Either a equals c, or both a and b are true
    ///
    /// Expression: `(!(a ^ c) | (a & b))`
    #[strum(props(Expr = "(!(a ^ c) | (a & b))"))]
    OrBiimpACAndAB3 = 0x3_ad,
    /// Implies(Implies(b, c), a)
    ///
    /// Expression: `(!(!b | c) | a)`
    #[strum(props(Expr = "(!(!b | c) | a)"))]
    ImpliesImpliesBCA3 = 0x3_ae,
    /// Implies(c, a).
    ///
    /// Expression: `(!c | a)`
    #[strum(props(Expr = "(!c | a)"))]
    ImpliesCA3 = 0x3_af,
    /// And(c, Or(a, not b))
    ///
    /// Expression: `(c & (a | !b))`
    #[strum(props(Expr = "(c & (a | !b))"))]
    AndCOrANotB3 = 0x3_b0,
    /// If a then c else not b (multiplexer, negated input).
    ///
    /// Expression: `(a & c | !a & !b)`
    ///
    /// Aliases: `MuxACNotB3`
    #[strum(props(Expr = "(a & c | !a & !b)"))]
    IfACNotB3 = 0x3_b1,
    /// Majority function (true when least 2 of a, not b, c are true)
    ///
    /// Expression: `(a & !b | a & c | !b & c)`
    #[strum(props(Expr = "(a & !b | a & c | !b & c)"))]
    Majority3ANotBC3 = 0x3_b2,
    /// b implies And(a, c).
    ///
    /// Expression: `(!b | (a & c))`
    #[strum(props(Expr = "(!b | (a & c))"))]
    ImpliesBAndAC3 = 0x3_b3,
    /// Variable c differs from both not-a and b
    ///
    /// Expression: `(c ^ (!a & b))`
    #[strum(props(Expr = "(c ^ (!a & b))"))]
    XorCAndNotAB3 = 0x3_b4,
    /// Either a equals c, or neither a nor b is true
    ///
    /// Expression: `!((a ^ c) & (a | b))`
    #[strum(props(Expr = "!((a ^ c) & (a | b))"))]
    NotAndXorACOrAB3 = 0x3_b5,
    /// Either odd parity of all three, or both a and c are true
    ///
    /// Expression: `((a ^ b ^ c) | (a & c))`
    #[strum(props(Expr = "((a ^ b ^ c) | (a & c))"))]
    OrXor3ABCAndAC3 = 0x3_b6,
    /// Xor(a, c) implies not b.
    ///
    /// Expression: `(!(a ^ c) | !b)`
    #[strum(props(Expr = "(!(a ^ c) | !b)"))]
    ImpliesXorACNotB3 = 0x3_b7,
    /// If b then a else c (multiplexer).
    ///
    /// Expression: `(b & a | !b & c)`
    ///
    /// Aliases: `MuxBAC3`
    #[strum(props(Expr = "(b & a | !b & c)"))]
    IfBAC3 = 0x3_b8,
    /// Either a equals b, or both a and c are true
    ///
    /// Expression: `(!(a ^ b) | (a & c))`
    #[strum(props(Expr = "(!(a ^ b) | (a & c))"))]
    OrBiimpABAndAC3 = 0x3_b9,
    /// Implies(Implies(c, b), a)
    ///
    /// Expression: `(!(!c | b) | a)`
    #[strum(props(Expr = "(!(!c | b) | a)"))]
    ImpliesImpliesCBA3 = 0x3_ba,
    /// Reverse implication (B implies A).
    ///
    /// Expression: `(!b | a)`
    ///
    /// Note: Promoted from `ImpliesBA2` (arity 2).
    ///
    /// Aliases: `OrANotB2`
    #[strum(props(Expr = "(!b | a)"))]
    ImpliesBA3 = 0x3_bb,
    /// Either b differs from c, or both a and b are true
    ///
    /// Expression: `((b ^ c) | (a & b))`
    #[strum(props(Expr = "((b ^ c) | (a & b))"))]
    OrXorBCAndAB3 = 0x3_bc,
    /// Variable a equals at least one of b or c
    ///
    /// Expression: `!((a ^ b) & (a ^ c))`
    #[strum(props(Expr = "!((a ^ b) & (a ^ c))"))]
    NotAndXorABXorAC3 = 0x3_bd,
    /// Biimp(b, c) implies a.
    ///
    /// Expression: `((b ^ c) | a)`
    #[strum(props(Expr = "((b ^ c) | a)"))]
    OrXorBCA3 = 0x3_be,
    /// False only when all of a, not b, and not c are.
    ///
    /// Expression: `!(!a & b & c)`
    #[strum(props(Expr = "!(!a & b & c)"))]
    NotAnd3NotABC3 = 0x3_bf,
    /// And(b, c).
    ///
    /// Expression: `(b & c)`
    #[strum(props(Expr = "(b & c)"))]
    AndBC3 = 0x3_c0,
    /// True iff b == c and b == ( a or c ).
    ///
    /// Expression: `(!(b ^ c) & (!a | b))`
    #[strum(props(Expr = "(!(b ^ c) & (!a | b))"))]
    AndBiimpBCOrNotAB3 = 0x3_c1,
    /// Variables b and c are equal, while at least one of a or b
    ///
    /// Expression: `(!(b ^ c) & (a | b))`
    #[strum(props(Expr = "(!(b ^ c) & (a | b))"))]
    AndBiimpBCOrAB3 = 0x3_c2,
    /// Biimp(b, c).
    ///
    /// Expression: `!(b ^ c)`
    #[strum(props(Expr = "!(b ^ c)"))]
    BiimpBC3 = 0x3_c3,
    /// And(b, Or(not a, c))
    ///
    /// Expression: `(b & (!a | c))`
    #[strum(props(Expr = "(b & (!a | c))"))]
    AndBOrNotAC3 = 0x3_c4,
    /// If c then b else not a (multiplexer, negated input).
    ///
    /// Expression: `(c & b | !c & !a)`
    ///
    /// Aliases: `MuxCBNotA3`
    #[strum(props(Expr = "(c & b | !c & !a)"))]
    IfCBNotA3 = 0x3_c5,
    /// Variable b equals (a implies c)
    ///
    /// Expression: `!(b ^ (!a | c))`
    #[strum(props(Expr = "!(b ^ (!a | c))"))]
    BiimpBOrNotAC3 = 0x3_c6,
    /// Either b equals c, or neither a nor c is true
    ///
    /// Expression: `!((b ^ c) & (a | c))`
    #[strum(props(Expr = "!((b ^ c) & (a | c))"))]
    NotAndXorBCOrAC3 = 0x3_c7,
    /// And(b, Or(a, c))
    ///
    /// Expression: `(b & (a | c))`
    #[strum(props(Expr = "(b & (a | c))"))]
    AndBOrAC3 = 0x3_c8,
    /// Variable b equals the disjunction of a and c
    ///
    /// Expression: `!(b ^ (a | c))`
    #[strum(props(Expr = "!(b ^ (a | c))"))]
    BiimpBOrAC3 = 0x3_c9,
    /// If c then b else a (multiplexer).
    ///
    /// Expression: `(c & b | !c & a)`
    ///
    /// Aliases: `MuxCBA3`
    #[strum(props(Expr = "(c & b | !c & a)"))]
    IfCBA3 = 0x3_ca,
    /// Either b equals c, or both a and b are true
    ///
    /// Expression: `(!(b ^ c) | (a & b))`
    #[strum(props(Expr = "(!(b ^ c) | (a & b))"))]
    OrBiimpBCAndAB3 = 0x3_cb,
    /// Identity on second variable.
    ///
    /// Expression: `b`
    ///
    /// Note: Promoted from `IdB2` (arity 2).
    #[strum(props(Expr = "b"))]
    IdB3 = 0x3_cc,
    /// Or(a, c) implies b.
    ///
    /// Expression: `(!(a | c) | b)`
    #[strum(props(Expr = "(!(a | c) | b)"))]
    ImpliesOrACB3 = 0x3_cd,
    /// Implies(Implies(a, c), b)
    ///
    /// Expression: `(!(!a | c) | b)`
    #[strum(props(Expr = "(!(!a | c) | b)"))]
    ImpliesImpliesACB3 = 0x3_ce,
    /// Implies(c, b).
    ///
    /// Expression: `(!c | b)`
    #[strum(props(Expr = "(!c | b)"))]
    ImpliesCB3 = 0x3_cf,
    /// And(c, Or(not a, b))
    ///
    /// Expression: `(c & (!a | b))`
    #[strum(props(Expr = "(c & (!a | b))"))]
    AndCOrNotAB3 = 0x3_d0,
    /// If b then c else not a (multiplexer, negated input).
    ///
    /// Expression: `(b & c | !b & !a)`
    ///
    /// Aliases: `MuxBCNotA3`
    #[strum(props(Expr = "(b & c | !b & !a)"))]
    IfBCNotA3 = 0x3_d1,
    /// Variable c equals (a implies b)
    ///
    /// Expression: `!(c ^ (!a | b))`
    #[strum(props(Expr = "!(c ^ (!a | b))"))]
    BiimpCOrNotAB3 = 0x3_d2,
    /// Either b equals c, or neither a nor b is true
    ///
    /// Expression: `!((b ^ c) & (a | b))`
    #[strum(props(Expr = "!((b ^ c) & (a | b))"))]
    NotAndXorBCOrAB3 = 0x3_d3,
    /// Majority function (true when least 2 of not a, b, c are true)
    ///
    /// Expression: `(!a & b | !a & c | b & c)`
    #[strum(props(Expr = "(!a & b | !a & c | b & c)"))]
    Majority3NotABC3 = 0x3_d4,
    /// a implies And(b, c).
    ///
    /// Expression: `(!a | (b & c))`
    #[strum(props(Expr = "(!a | (b & c))"))]
    ImpliesAAndBC3 = 0x3_d5,
    /// Either odd parity of all three, or both b and c are true
    ///
    /// Expression: `((a ^ b ^ c) | (b & c))`
    #[strum(props(Expr = "((a ^ b ^ c) | (b & c))"))]
    OrXor3ABCAndBC3 = 0x3_d6,
    /// Xor(b, c) implies not a.
    ///
    /// Expression: `(!(b ^ c) | !a)`
    #[strum(props(Expr = "(!(b ^ c) | !a)"))]
    ImpliesXorBCNotA3 = 0x3_d7,
    /// If a then b else c (multiplexer).
    ///
    /// Expression: `(a & b | !a & c)`
    ///
    /// Aliases: `MuxABC3`
    #[strum(props(Expr = "(a & b | !a & c)"))]
    IfABC3 = 0x3_d8,
    /// Either a equals b, or both b and c are true
    ///
    /// Expression: `(!(a ^ b) | (b & c))`
    #[strum(props(Expr = "(!(a ^ b) | (b & c))"))]
    OrBiimpABAndBC3 = 0x3_d9,
    /// Either a differs from c, or both a and b are true
    ///
    /// Expression: `((a ^ c) | (a & b))`
    #[strum(props(Expr = "((a ^ c) | (a & b))"))]
    OrXorACAndAB3 = 0x3_da,
    /// Variable a equals b, or a differs from c
    ///
    /// Expression: `(!(a ^ b) | (a ^ c))`
    #[strum(props(Expr = "(!(a ^ b) | (a ^ c))"))]
    OrBiimpABXorAC3 = 0x3_db,
    /// Implies(Implies(c, a), b)
    ///
    /// Expression: `(!(!c | a) | b)`
    #[strum(props(Expr = "(!(!c | a) | b)"))]
    ImpliesImpliesCAB3 = 0x3_dc,
    /// Material implication (A implies B).
    ///
    /// Expression: `(!a | b)`
    ///
    /// Note: Promoted from `ImpliesAB2` (arity 2).
    ///
    /// Aliases: `OrNotAB2`
    #[strum(props(Expr = "(!a | b)"))]
    ImpliesAB3 = 0x3_dd,
    /// Biimp(a, c) implies b.
    ///
    /// Expression: `((a ^ c) | b)`
    #[strum(props(Expr = "((a ^ c) | b)"))]
    OrXorACB3 = 0x3_de,
    /// False only when all of not a, b, and not c are.
    ///
    /// Expression: `!(a & !b & c)`
    #[strum(props(Expr = "!(a & !b & c)"))]
    NotAnd3ANotBC3 = 0x3_df,
    /// And(c, Or(a, b))
    ///
    /// Expression: `(c & (a | b))`
    #[strum(props(Expr = "(c & (a | b))"))]
    AndCOrAB3 = 0x3_e0,
    /// Variable c equals the disjunction of a and b
    ///
    /// Expression: `!(c ^ (a | b))`
    #[strum(props(Expr = "!(c ^ (a | b))"))]
    BiimpCOrAB3 = 0x3_e1,
    /// If b then c else a (multiplexer).
    ///
    /// Expression: `(b & c | !b & a)`
    ///
    /// Aliases: `MuxBCA3`
    #[strum(props(Expr = "(b & c | !b & a)"))]
    IfBCA3 = 0x3_e2,
    /// Either b equals c, or both a and c are true
    ///
    /// Expression: `(!(b ^ c) | (a & c))`
    #[strum(props(Expr = "(!(b ^ c) | (a & c))"))]
    OrBiimpBCAndAC3 = 0x3_e3,
    /// If a then c else b (multiplexer).
    ///
    /// Expression: `(a & c | !a & b)`
    ///
    /// Aliases: `MuxACB3`
    #[strum(props(Expr = "(a & c | !a & b)"))]
    IfACB3 = 0x3_e4,
    /// Either a equals c, or both b and c are true
    ///
    /// Expression: `(!(a ^ c) | (b & c))`
    #[strum(props(Expr = "(!(a ^ c) | (b & c))"))]
    OrBiimpACAndBC3 = 0x3_e5,
    /// Either a differs from b, or both a and c are true
    ///
    /// Expression: `((a ^ b) | (a & c))`
    #[strum(props(Expr = "((a ^ b) | (a & c))"))]
    OrXorABAndAC3 = 0x3_e6,
    /// Variable a differs from b, or a equals c
    ///
    /// Expression: `((a ^ b) | !(a ^ c))`
    #[strum(props(Expr = "((a ^ b) | !(a ^ c))"))]
    OrXorABBiimpAC3 = 0x3_e7,
    /// Majority function (at least 2 of 3 true).
    ///
    /// Expression: `(a & b | a & c | b & c)`
    ///
    /// Aliases: `CarryABC3`
    #[strum(props(Expr = "(a & b | a & c | b & c)"))]
    Majority3ABC3 = 0x3_e8,
    /// Either even parity of all three, or both a and b are true
    ///
    /// Expression: `((!a ^ b ^ c) | (a & b))`
    #[strum(props(Expr = "((!a ^ b ^ c) | (a & b))"))]
    OrNotXor3ABCAndAB3 = 0x3_e9,
    /// NotAnd(b, c) implies a.
    ///
    /// Expression: `((b & c) | a)`
    #[strum(props(Expr = "((b & c) | a)"))]
    OrAndBCA3 = 0x3_ea,
    /// Xor(b, c) implies a.
    ///
    /// Expression: `(!(b ^ c) | a)`
    #[strum(props(Expr = "(!(b ^ c) | a)"))]
    ImpliesXorBCA3 = 0x3_eb,
    /// NotAnd(a, c) implies b.
    ///
    /// Expression: `((a & c) | b)`
    #[strum(props(Expr = "((a & c) | b)"))]
    OrAndACB3 = 0x3_ec,
    /// Xor(a, c) implies b.
    ///
    /// Expression: `(!(a ^ c) | b)`
    #[strum(props(Expr = "(!(a ^ c) | b)"))]
    ImpliesXorACB3 = 0x3_ed,
    /// Logical OR (Exclusive Or) operator on first two variables.
    ///
    /// Expression: `(a | b)`
    ///
    /// Note: Promoted from `OrAB2` (arity 2).
    #[strum(props(Expr = "(a | b)"))]
    OrAB3 = 0x3_ee,
    /// False only when all of a, b, and not c are.
    ///
    /// Expression: `(a | b | !c)`
    #[strum(props(Expr = "(a | b | !c)"))]
    Or3ABNotC3 = 0x3_ef,
    /// Identity function on c.
    ///
    /// Expression: `c`
    #[strum(props(Expr = "c"))]
    IdC3 = 0x3_f0,
    /// Or(a, b) implies c.
    ///
    /// Expression: `(!(a | b) | c)`
    #[strum(props(Expr = "(!(a | b) | c)"))]
    ImpliesOrABC3 = 0x3_f1,
    /// Implies(Implies(a, b), c)
    ///
    /// Expression: `(!(!a | b) | c)`
    #[strum(props(Expr = "(!(!a | b) | c)"))]
    ImpliesImpliesABC3 = 0x3_f2,
    /// Implies(b, c).
    ///
    /// Expression: `(!b | c)`
    #[strum(props(Expr = "(!b | c)"))]
    ImpliesBC3 = 0x3_f3,
    /// Implies(Implies(b, a), c)
    ///
    /// Expression: `(!(!b | a) | c)`
    #[strum(props(Expr = "(!(!b | a) | c)"))]
    ImpliesImpliesBAC3 = 0x3_f4,
    /// Implies(a, c).
    ///
    /// Expression: `(!a | c)`
    #[strum(props(Expr = "(!a | c)"))]
    ImpliesAC3 = 0x3_f5,
    /// Biimp(a, b) implies c.
    ///
    /// Expression: `((a ^ b) | c)`
    #[strum(props(Expr = "((a ^ b) | c)"))]
    OrXorABC3 = 0x3_f6,
    /// False only when all of not a, not b, and c are.
    ///
    /// Expression: `!(a & b & !c)`
    #[strum(props(Expr = "!(a & b & !c)"))]
    NotAnd3ABNotC3 = 0x3_f7,
    /// NotAnd(a, b) implies c.
    ///
    /// Expression: `((a & b) | c)`
    #[strum(props(Expr = "((a & b) | c)"))]
    OrAndABC3 = 0x3_f8,
    /// Xor(a, b) implies c.
    ///
    /// Expression: `(!(a ^ b) | c)`
    #[strum(props(Expr = "(!(a ^ b) | c)"))]
    ImpliesXorABC3 = 0x3_f9,
    /// Or(a, c).
    ///
    /// Expression: `(a | c)`
    #[strum(props(Expr = "(a | c)"))]
    OrAC3 = 0x3_fa,
    /// False only when all of a, not b, and c are.
    ///
    /// Expression: `(a | !b | c)`
    #[strum(props(Expr = "(a | !b | c)"))]
    Or3ANotBC3 = 0x3_fb,
    /// Or(b, c).
    ///
    /// Expression: `(b | c)`
    #[strum(props(Expr = "(b | c)"))]
    OrBC3 = 0x3_fc,
    /// False only when all of not a, b, and c are.
    ///
    /// Expression: `(!a | b | c)`
    #[strum(props(Expr = "(!a | b | c)"))]
    Or3NotABC3 = 0x3_fd,
    /// Three-way OR operator.
    ///
    /// Expression: `(a | b | c)`
    #[strum(props(Expr = "(a | b | c)"))]
    Or3ABC3 = 0x3_fe,
    /// Constant true. See `True0`.
    ///
    /// Expression: `true`
    ///
    /// Note: Promoted from `True0` (arity 0).
    #[strum(props(Expr = "true"))]
    True3 = 0x3_ff,
}

impl BooleanSimpleOp {
    /// Get the arity of the operator.
    #[inline]
    pub fn get_arity(&self) -> u8 {
        ((*self as u16 >> 8) & 0x3) as u8
    }

    /// Get the truth table of the operator as if it applied to 3 variables.
    ///
    /// This is compatible with Mathematica's
    /// `BooleanFunction[code3, {a, b, c}]`.
    ///
    /// The reduced truth table is
    /// `code_n = (code3 >> 0) & ((1 << (1 << n)) - 1)`
    /// where `n` is the arity.
    #[inline]
    pub fn get_code3(&self) -> u8 {
        (*self as u16 & 0xff) as u8
    }
}
